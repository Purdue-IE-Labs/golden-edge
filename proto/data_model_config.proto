syntax = "proto3";

import "type.proto";
import "data_model_session.proto";

// Although both path and version can be found in the keyspace, we include them 
// here for traceability back to where we originally got the model

// TODO: does a model need props? Or just the items on it?
// If so, we could add a Config to this, but it would just need to 
// be known that the config will always be the DataModelType
message DataModelConfig {
    string path = 1; // we just use a path here because it should not include a version
    uint32 version = 2;
    DataModelObjectConfig parent = 3; // we need both path and version here to know what are we depending on
	repeated DataModelItemConfig items = 4;
}

message DataModelItemConfig {
    string path = 1;
    DataObjectConfig config = 2;
}

/*
We have reached a generic from of a config object. It consists of 
either the type (if base type) or [either the model path or expanded model definition]
along with properties
*/
message DataObjectConfig {
    Config config = 2;
    Props props = 3;
}

// an embedded data model can take two forms: a path, or the whole config object
message DataModelObjectConfig {
    /*
    repr -> representation. The representation of this model as either just path
    or as embedded
    */
    oneof repr {
        DataModelType path = 1;
        DataModelConfig embedded = 2;
    }
}

message Config {
    oneof config {
        BaseType base_config = 1;
        DataModelObjectConfig data_model_config = 2;
    }
}

// We require a Prop object because it is distinct from Body and Param
// In those cases, we are specifying strictly configurations (i.e. 
// type and props) while a Prop is a type and a value
// We include it in this file because otherwise we get recursive imports
message Prop {
    Config config = 1;
    DataObject value = 2;
}

message Props {
    map<string, Prop> props = 1;
}